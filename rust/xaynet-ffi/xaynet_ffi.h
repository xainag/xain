/* Generated with cbindgen:0.15.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * ByteBuffer
 * A helper struct for sequences with an unknown size at compile-time.
 */
typedef struct BytesBuffer BytesBuffer;

/**
 * A Opaque type of MobileClient.
 * see [FFI-C-OPAQUE](https://anssi-fr.github.io/rust-guide/07_ffi.html#recommendation-a-idffi-c-opaqueaffi-c-opaque)
 */
typedef struct CMobileClient CMobileClient;

/**
 * `FfiStr<'a>` is a safe (`#[repr(transparent)]`) wrapper around a
 * nul-terminated `*const c_char` (e.g. a C string). Conceptually, it is
 * similar to [`std::ffi::CStr`], except that it may be used in the signatures
 * of extern "C" functions.
 *
 * Functions accepting strings should use this instead of accepting a C string
 * directly. This allows us to write those functions using safe code without
 * allowing safe Rust to cause memory unsafety.
 *
 * A single function for constructing these from Rust ([`FfiStr::from_raw`])
 * has been provided. Most of the time, this should not be necessary, and users
 * should accept `FfiStr` in the parameter list directly.
 *
 * ## Caveats
 *
 * An effort has been made to make this struct hard to misuse, however it is
 * still possible, if the `'static` lifetime is manually specified in the
 * struct. E.g.
 *
 * ```rust,no_run
 * # use ffi_support::FfiStr;
 * // NEVER DO THIS
 * #[no_mangle]
 * extern "C" fn never_do_this(s: FfiStr<'static>) {
 *     // save `s` somewhere, and access it after this
 *     // function returns.
 * }
 * ```
 *
 * Instead, one of the following patterns should be used:
 *
 * ```
 * # use ffi_support::FfiStr;
 * #[no_mangle]
 * extern "C" fn valid_use_1(s: FfiStr<'_>) {
 *     // Use of `s` after this function returns is impossible
 * }
 * // Alternative:
 * #[no_mangle]
 * extern "C" fn valid_use_2(s: FfiStr) {
 *     // Use of `s` after this function returns is impossible
 * }
 * ```
 */
typedef const char *FfiStr;

/**
 * Initializes a fresh [`CMobileClient`]. This method only needs to be called once.
 *
 * To serialize and restore a client use the
 * [`xaynet_ffi_serialize_mobile_client`] and [`xaynet_ffi_restore_mobile_client`].
 *
 * # Parameters
 *
 * - `url`: The URL fo the coordinator to which the [`MobileClient`] will try to connect to.
 * - `secret_key`: The array that contains the secret key.
 * - `group_type`: The [`GroupType`].
 * - `data_type`: The [`DataType`].
 * - `bound_type`: The [`BoundType`].
 * - `model_type`: The [`ModelType`].
 * - `scalar`: The scalar.
 * - `certificates`: The optional array of paths to DER/PEM encoded trusted server certificates for
 *   TLS server authentication. Requires the `tls` feature to be enabled. Interprets null pointers
 *   as `None` and is ignored for `certificates_len` of zero.
 * - `certificates_len`: The number of DER/PEM encoded optional certificates. Requires the `tls`
 *   feature to be enabled. Interprets zero as `None`.
 * - `identity`: The optional path to a PEM encoded client certificate for TLS client
 *   authentication. Requires the `tls` feature to be enabled. Interprets a null pointer as `None`.
 *
 * Requires at least one of the following arguments if the `tls` feature is enabled:
 * - `certificates` together with `certificates_len`
 * - `identity`
 *
 * # Safety
 *
 * `secret_key`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of `c_uchar`,
 * - the data the pointer points to is properly aligned,
 * - the data is valid for reads for [`ParticipantSecretKey::LENGTH`]` * mem::size_of::<c_uchar>()`
 * many bytes,
 * - the memory of secret_key is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_init_mobile_client`].
 *
 * `certificates`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of `*const FfiStr`
 * - the data the pointers point to are properly aligned and valid UTF-8,
 * - the data is valid for reads for `certificates_len * mem::size_of::<*const _>()` many bytes,
 * - the memory of the certificates is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_init_mobile_client`].
 *
 * `identity`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of `c_char`
 * - the data the pointer points to is properly aligned and valid UTF-8,
 * - the memory of the identity is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_init_mobile_client`].
 *
 * # Return Value
 *
 * Returns a new instance of [`CMobileClient`].
 *
 * ## Returns `NULL` if:
 *
 * - a value of `group_type`, `data_type`, `bound_type` or `model_type` is not a valid value
 * (see the module documentation of [`xaynet_core::mask`] for more information),
 * - the pointer of `url` or `secret_key` points to `NULL`,
 * - the `url` contains invalid UTF-8 characters.
 * - the TLS settings are invalid
 *
 * [`MobileClient`]: xaynet_client::mobile_client::MobileClient
 */
CMobileClient *xaynet_ffi_init_mobile_client(FfiStr url,
                                             const unsigned char *secret_key,
                                             unsigned char group_type,
                                             unsigned char data_type,
                                             unsigned char bound_type,
                                             unsigned char model_type,
                                             double scalar);

/**
 * Restores a [`MobileClient`] from its serialized state.
 *
 * # Parameters
 *
 * - `url`: The URL fo the coordinator to which the [`MobileClient`] will try to connect to.
 * - `buffer`: The array that contains the serialized state.
 * - `len`: The length of `buffer`.
 * - `certificates`: The optional array of paths to DER/PEM encoded trusted server certificates for
 *   TLS server authentication. Requires the `tls` feature to be enabled. Interprets null pointers
 *   as `None` and is ignored for `certificates_len` of zero.
 * - `certificates_len`: The number of DER/PEM encoded optional certificates. Requires the `tls`
 *   feature to be enabled. Interprets zero as `None`.
 * - `identity`: The optional path to a PEM encoded client certificate for TLS client
 *   authentication. Requires the `tls` feature to be enabled. Interprets a null pointer as `None`.
 *
 * Requires at least one of the following arguments if the `tls` feature is enabled:
 * - `certificates` together with `certificates_len`
 * - `identity`
 *
 * # Safety
 *
 * `buffer`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of `c_uchar`,
 * - the data the pointer points to is properly aligned,
 * - the data is valid for reads for `len` * mem::size_of::<c_uchar>() many bytes,
 * - the memory of `buffer` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_restore_mobile_client`].
 *
 * `certificates`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of `*const FfiStr`
 * - the data the pointers point to are properly aligned and valid UTF-8,
 * - the data is valid for reads for `certificates_len * mem::size_of::<*const _>()` many bytes,
 * - the memory of the certificates is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_restore_mobile_client`].
 *
 * `identity`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of `c_char`
 * - the data the pointer points to is properly aligned and valid UTF-8,
 * - the memory of the identity is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_restore_mobile_client`].
 *
 * # Return Value
 *
 * Returns a new instance of [`CMobileClient`].
 *
 * ## Returns `NULL` if:
 *
 * - the pointer of `url` or `buffer` points to `NULL`,
 * - `url` contains invalid UTF-8 characters.
 * - the TLS settings are invalid
 *
 * [`MobileClient`]: xaynet_client::mobile_client::MobileClient
 */
CMobileClient *xaynet_ffi_restore_mobile_client(FfiStr url,
                                                const unsigned char *buffer,
                                                unsigned int buffer_len);

/**
 * Serializes the current state of `client`.
 *
 * # Parameters
 *
 * - `client`: A pointer that points to an instance of [`CMobileClient`].
 *
 * # Safety
 *
 * `client`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of [`CMobileClient`],
 * - the data the pointer points to is properly aligned,
 * - the memory of `client` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_serialize_mobile_client`].
 *
 * # Return Value
 *
 * Returns a new instance of [`BytesBuffer`] that contains the serialized state of `client`.
 *
 * ## Returns `NULL` if:
 *
 * - the pointer of `client` points to `NULL`.
 */
BytesBuffer *xaynet_ffi_serialize_mobile_client(const CMobileClient *client);

/**
 * Tries to proceed with the current client task.
 * This will consume the current state of the client and produces a new one.
 *
 * # Parameters
 *
 * - `client`: A pointer that points to an instance of [`CMobileClient`].
 *
 * # Safety
 *
 * `client`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of [`CMobileClient`],
 * - the data the pointer points to is properly aligned,
 * - the memory of `client` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_get_current_state_mobile_client`].
 *
 * # Return Value
 *
 * Returns a new instance of [`CMobileClient`].
 *
 * ## Returns `NULL` if:
 *
 * - the pointer of `client` points to `NULL`.
 */
CMobileClient *xaynet_ffi_try_to_proceed_mobile_client(CMobileClient *client);

/**
 * Returns the current state of `client`.
 *
 * # Parameters
 *
 * - `client`: A pointer that points to an instance of [`CMobileClient`].
 *
 * # Safety
 *
 * `client`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of [`CMobileClient`],
 * - the data the pointer points to is properly aligned,
 * - the memory of `client` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_get_current_state_mobile_client`].
 *
 * # Return Value
 *
 * - `-1`: the pointer of `client` points to `NULL`,
 * - `0`: `Awaiting` state,
 * - `1`: `Sum` state,
 * - `2`: `Update` state,
 * - `3`: `Sum2` state.
 */
int xaynet_ffi_get_current_state_mobile_client(CMobileClient *client);

/**
 * # Safety
 * This is equivalent to calling Box::from_raw with panic handling, and
 * thus inherits [`Box::from_raw`]'s safety properties. That is to say,
 * this function is wildly unsafe.
 */
void xaynet_ffi_destroy_mobile_client(CMobileClient *v);

/**
 * Fetches and returns the latest global model from the coordinator.
 *
 * # Parameters
 *
 * - `client`: A pointer that points to an instance of [`CMobileClient`].
 * - `data_type`: The [`DataType`] of the global model.
 * - `buffer`: The array in which the global model should be copied.
 * - `len`: The length of `buffer`.
 *
 * # Note
 *
 * The data type must match the data type that was used when the client was initialized.
 *
 * # Safety
 *
 * `client`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of [`CMobileClient`],
 * - the data the pointer points to is properly aligned,
 * - the memory of `client` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_get_global_model_mobile_client`].
 *
 * `buffer`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of `c_void`,
 * - the data the pointer points to is properly aligned,
 * - the data is valid for writes for `len` * mem::size_of::<c_void>() many bytes,
 * - the memory of `buffer` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_get_global_model_mobile_client`].
 *
 * # Return Value
 *
 * - `-1`: the pointer of `client` points to `NULL`,
 * - `-2`: the pointer of `buffer` points to `NULL`,
 * - `-3`: the value of `data_type` is not a valid value (see the module documentation of [`xaynet_core::mask`] for more information),
 * - `-4`: the API request failed,
 * - `-5`: the global model does not fit into `buffer`,
 * - `-6`: the pointer of `client` points to `NULL`,
 * - `0`: success,
 * - `1`: no global model available,
 */
int xaynet_ffi_get_global_model_mobile_client(CMobileClient *client,
                                              unsigned char data_type,
                                              void *buffer,
                                              unsigned int len);

/**
 * Sets the local model.
 *
 * The local model is only sent if the client has been selected as an update client.
 * If the client is an update client and no local model is available, the client remains
 * in this state until a local model has been set or a new round has been started by the
 * coordinator.
 *
 * # Parameters
 *
 * - `client`: A pointer that points to an instance of [`CMobileClient`].
 * - `data_type`: The [`DataType`] of the local model.
 * - `buffer`: The array in which the local model should be copied.
 * - `len`: The length of `buffer`.
 *
 * # Note
 *
 * The data type must match the data type that was used when the client was initialized.
 *
 * # Safety
 *
 * `client`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of [`CMobileClient`],
 * - the data the pointer points to is properly aligned,
 * - the memory of `client` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_set_local_model_mobile_client`].
 *
 * `buffer`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of `c_void`,
 * - the data the pointer points to is properly aligned,
 * - the data is valid for writes for `len` * mem::size_of::<c_void>() many bytes,
 * - the memory of `buffer` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_set_local_model_mobile_client`].
 *
 * # Return Value
 *
 * - `-1`: the pointer of `client` points to `NULL`,
 * - `-2`: the pointer of `buffer` points to `NULL`,
 * - `-3`: the value of `data_type` is not a valid value (see the module documentation of [`xaynet_core::mask`] for more information),
 * - `-4`: failed to create a model,
 * - `0`: success,
 */
int xaynet_ffi_set_local_model_mobile_client(CMobileClient *client,
                                             unsigned char data_type,
                                             const void *buffer,
                                             unsigned int len);

/**
 * Creates a new participant secret key and writes it into `buffer`.
 *
 * # Parameters
 *
 * - `buffer`: A pointer that points to an instance of `c_uchar`.
 *
 * # Safety
 *
 * `buffer`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of `c_uchar`,
 * - the data the pointer points to is properly aligned,
 * - the data is valid for writes for [`ParticipantSecretKey::LENGTH`] * mem::size_of::<c_uchar>()
 * many bytes,
 * - the memory of `buffer` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_new_secret_key`].
 *
 * # Return Value
 *
 * - `-1`: the pointer of `buffer` points to `NULL`,
 * - `0`: success.
 */
int xaynet_ffi_new_secret_key(unsigned char *buffer);

/**
 * # Safety
 * This is equivalent to calling Box::from_raw with panic handling, and
 * thus inherits [`Box::from_raw`]'s safety properties. That is to say,
 * this function is wildly unsafe.
 */
void xaynet_ffi_destroy_byte_buffer(BytesBuffer *v);

/**
 * Returns the length of `buffer`.
 *
 * # Parameters
 *
 * - `buffer`: A pointer that points to an instance of [`BytesBuffer`].
 *
 * # Safety
 *
 * `buffer`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of [`BytesBuffer`],
 * - the memory of `buffer` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_get_len_of_byte_buffer`].
 *
 * # Return Value
 *
 * - `-1`: the pointer of `buffer` points to `NULL`,
 * - `> -1`: the length of `buffer`.
 */
int xaynet_ffi_get_len_of_byte_buffer(const BytesBuffer *buffer);

/**
 * Copies the content of `buffer` into `foreign_buffer`.
 *
 * # Parameters
 *
 * - `buffer`: A pointer that points to an instance of [`BytesBuffer`].
 * - `foreign_buffer`: A pointer that points to an instance of `c_uchar`.
 *
 * # Safety
 *
 * `buffer`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of [`BytesBuffer`],
 * - the memory of `buffer` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_copy_into_foreign_buffer`].
 *
 * `foreign_buffer`:
 *
 * The function only ensures null-safety. You must ensure that:
 * - the pointer points to an initialized instance of `c_uchar`,
 * - the data the pointer points to is properly aligned,
 * - the data is valid for writes for `buffer_length` * mem::size_of::<c_uchar>() many bytes,
 * - the memory of `foreign_buffer` is not mutated (from the outside of this function)
 * for the duration of the execution of [`xaynet_ffi_copy_into_foreign_buffer`].
 *
 * # Return Value
 *
 * - `-1`: the pointer of `buffer` points to `NULL`,
 * - `-2`: the pointer of `foreign_buffer` points to `NULL`,
 * - `0`: success.
 */
int xaynet_ffi_copy_into_foreign_buffer(const BytesBuffer *buffer, unsigned char *foreign_buffer);
